# Let's create a Python implementation that:
# - Splits a piece of 882,488 bytes into 16 KiB (16384-byte) blocks
# - Sends up to 5 requests at a time (pipelined)
# - Simulates receiving and matching `piece` responses
# We'll simulate sending/receiving with queues instead of real sockets for clarity.

from queue import Queue
from threading import Thread, Lock
import struct
import time

# Constants
PIECE_LENGTH = 882_488
BLOCK_SIZE = 16 * 1024  # 16 KiB
PIPELINE_LIMIT = 5
PIECE_INDEX = 0  # Example piece index

# Shared structures
request_queue = Queue()
response_queue = Queue()
received_blocks = {}
lock = Lock()

# Simulated sender: sends up to PIPELINE_LIMIT requests at a time
def request_sender():
    offset = 0
    pending = 0

    while offset < PIECE_LENGTH or pending > 0:
        while pending < PIPELINE_LIMIT and offset < PIECE_LENGTH:
            block_len = min(BLOCK_SIZE, PIECE_LENGTH - offset)
            payload = struct.pack(">IbIII", 13, 6, PIECE_INDEX, offset, block_len)
            request_queue.put((PIECE_INDEX, offset, block_len, payload))
            offset += block_len
            pending += 1
        time.sleep(0.01)

        # Simulate piece being received
        while not response_queue.empty():
            index, begin, block_data = response_queue.get()
            with lock:
                received_blocks[begin] = block_data
            pending -= 1

# Simulated peer: responds with piece data for every request
def peer_simulator():
    while True:
        try:
            index, begin, length, _ = request_queue.get(timeout=1)
            # Simulate response data
            block_data = b"x" * length  # Dummy data
            piece_message = struct.pack(">BII", 7, index, begin) + block_data
            response_queue.put((index, begin, block_data))
        except:
            break

# Start the threads
t1 = Thread(target=request_sender)
t2 = Thread(target=peer_simulator)
t1.start()
t2.start()
t1.join()
t2.join()

# Final block count check
len(received_blocks), sum(len(v) for v in received_blocks.values()) == PIECE_LENGTH

